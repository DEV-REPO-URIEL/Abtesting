// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: proto/firebase_ml_log_sdk.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum EventName: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownEvent // = 0
  case modelDownload // = 100
  case modelUpdate // = 101
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownEvent
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownEvent
    case 100: self = .modelDownload
    case 101: self = .modelUpdate
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownEvent: return 0
    case .modelDownload: return 100
    case .modelUpdate: return 101
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension EventName: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [EventName] = [
    .unknownEvent,
    .modelDownload,
    .modelUpdate,
  ]
}

#endif  // swift(>=4.2)

/// A list of error codes for various components of the system. For model downloading, the
/// range of error codes is 100 to 199.
enum ErrorCode: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No error at all.
  case noError // = 0

  /// The download started on a valid condition but didn't finish successfully.
  case downloadFailed // = 104

  /// An unknown error has occurred. This is for conditions that should never
  /// happen. But we log them anyways.  If there is a surge in UNKNOWN error
  /// codes, we need to check our code.
  case unknownError // = 9999
  case UNRECOGNIZED(Int)

  init() {
    self = .noError
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noError
    case 104: self = .downloadFailed
    case 9999: self = .unknownError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noError: return 0
    case .downloadFailed: return 104
    case .unknownError: return 9999
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension ErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ErrorCode] = [
    .noError,
    .downloadFailed,
    .unknownError,
  ]
}

#endif  // swift(>=4.2)

/// Information about various parts of the system: app, Firebase, SDK.
struct SystemInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The application's unique id.  On iOS, this is the bundle ID.
  var appID: String = String()

  /// Application version string. On iOS, this is "version_number" + "#" + "build_number".
  var appVersion: String = String()

  /// Uniquely identifiable id associated with the Firebase project. Might be an
  /// empty string if the developer does not pass a correct FirebaseOptions with
  /// a valid Firebase Project ID.
  var firebaseProjectID: String = String()

  /// The API key of the firebase project.
  var apiKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information about models.
struct ModelInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the model defined by the model creator. This string should be
  /// meaningful to the creator and describes what the model does. For example,
  /// the name can be "mobile vision face recognition" or "speech to text".
  var name: String = String()

  /// The version of the model defined by the model creator.
  var version: String = String()

  /// The expected checksum (SHA256) of the model file. Only hash of models
  /// downloaded from cloud is logged.
  var hash: String = String()

  var modelType: ModelInfo.ModelType = .typeUnknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The model type is currently envisioned to be used mainly for model
  /// download/update.
  enum ModelType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case typeUnknown // = 0
    case custom // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .typeUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .typeUnknown
      case 1: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .typeUnknown: return 0
      case .custom: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ModelInfo.ModelType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ModelInfo.ModelType] = [
    .typeUnknown,
    .custom,
  ]
}

#endif  // swift(>=4.2)

/// Detailed information about a model.
/// The message used to be named "CustomModelOptions".
struct ModelOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Inherent properties about the model: name, version, URI, source.
  var modelInfo: ModelInfo {
    get {return _modelInfo ?? ModelInfo()}
    set {_modelInfo = newValue}
  }
  /// Returns true if `modelInfo` has been explicitly set.
  var hasModelInfo: Bool {return self._modelInfo != nil}
  /// Clears the value of `modelInfo`. Subsequent reads from it will return its default value.
  mutating func clearModelInfo() {self._modelInfo = nil}

  /// True if models can be updated.
  var isModelUpdateEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _modelInfo: ModelInfo? = nil
}

/// Information about model downloading. A single model download request may
/// result in multiple log entries. "download_status" in the log entry indicates
/// during which stage it is logged.
/// This message used to be named "CustomModelDownloadLogEvent".
struct ModelDownloadLogEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Model information and options for downloading.
  var options: ModelOptions {
    get {return _options ?? ModelOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {self._options = nil}

  /// The rough duration of the download. This is not marked as
  /// ST_SENSITIVE_TIMESTAMP because it is a duration instead of a timestamp.
  /// We delegate the download to OS downloader. We may not be notified
  /// when the download completes, such as when the app is killed.
  var roughDownloadDurationMs: UInt64 = 0

  /// The error code for model download.
  var errorCode: ErrorCode = .noError

  /// The exact duration of the download. This is not marked as
  /// ST_SENSITIVE_TIMESTAMP because it is a duration instead of a timestamp.
  /// We know the exact duration when the download is completed while the app is
  /// still alive and receives the completed notification from OS downloader.
  var exactDownloadDurationMs: UInt64 = 0

  /// The download status.
  var downloadStatus: ModelDownloadLogEvent.DownloadStatus = .unknownStatus

  /// If this field is logged for DownloadStatus.MODEL_INFO_RETRIEVAL_FAILED, it
  /// is the http status code from the firebase console. See
  /// go/firebase-ml-model-hosting-design. Same on both Android and iOS.
  /// If this field is logged for DownloadStatus.FAILED, it is the http status
  /// code on iOS, and the DownloadManager's "COLUMN_REASON" value on Android. On
  /// iOS, the status code can be a negative integer.
  /// See
  /// https://developer.android.com/reference/android/app/DownloadManager.html#COLUMN_REASON
  var downloadFailureStatus: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The download status. The model download is made up of two major stages: the
  /// retrieval of the model info in Firebase backend, and then the download of
  /// the model file in GCS. Whether or not the download is requested implicitly
  /// or explicitly does not affect the later stages of the download. As a
  /// result, later stages (i.e. enum tag 3+) do not distinguish between explicit
  /// and implicit triggering.
  enum DownloadStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknownStatus // = 0

    /// The download of the model file succeeded.
    case succeeded // = 7

    /// The download of the model file failed.
    case failed // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .unknownStatus
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownStatus
      case 7: self = .succeeded
      case 8: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknownStatus: return 0
      case .succeeded: return 7
      case .failed: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _options: ModelOptions? = nil
}

#if swift(>=4.2)

extension ModelDownloadLogEvent.DownloadStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ModelDownloadLogEvent.DownloadStatus] = [
    .unknownStatus,
    .succeeded,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// Main log event for FirebaseMl, that contains individual API events, like model
/// download.
/// NEXT ID: 44.
struct FirebaseMlLogEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information about various parts of the system: app, Firebase, SDK, TFLite.
  var systemInfo: SystemInfo {
    get {return _systemInfo ?? SystemInfo()}
    set {_systemInfo = newValue}
  }
  /// Returns true if `systemInfo` has been explicitly set.
  var hasSystemInfo: Bool {return self._systemInfo != nil}
  /// Clears the value of `systemInfo`. Subsequent reads from it will return its default value.
  mutating func clearSystemInfo() {self._systemInfo = nil}

  /// The event name.
  var eventName: EventName = .unknownEvent

  /// Model downloading logs.
  /// ==========================
  var modelDownloadLogEvent: ModelDownloadLogEvent {
    get {return _modelDownloadLogEvent ?? ModelDownloadLogEvent()}
    set {_modelDownloadLogEvent = newValue}
  }
  /// Returns true if `modelDownloadLogEvent` has been explicitly set.
  var hasModelDownloadLogEvent: Bool {return self._modelDownloadLogEvent != nil}
  /// Clears the value of `modelDownloadLogEvent`. Subsequent reads from it will return its default value.
  mutating func clearModelDownloadLogEvent() {self._modelDownloadLogEvent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _systemInfo: SystemInfo? = nil
  fileprivate var _modelDownloadLogEvent: ModelDownloadLogEvent? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension EventName: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_EVENT"),
    100: .same(proto: "MODEL_DOWNLOAD"),
    101: .same(proto: "MODEL_UPDATE"),
  ]
}

extension ErrorCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_ERROR"),
    104: .same(proto: "DOWNLOAD_FAILED"),
    9999: .same(proto: "UNKNOWN_ERROR"),
  ]
}

extension SystemInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SystemInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    2: .standard(proto: "app_version"),
    3: .standard(proto: "firebase_project_id"),
    7: .standard(proto: "api_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firebaseProjectID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.apiKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appID.isEmpty {
      try visitor.visitSingularStringField(value: self.appID, fieldNumber: 1)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 2)
    }
    if !self.firebaseProjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.firebaseProjectID, fieldNumber: 3)
    }
    if !self.apiKey.isEmpty {
      try visitor.visitSingularStringField(value: self.apiKey, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SystemInfo, rhs: SystemInfo) -> Bool {
    if lhs.appID != rhs.appID {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.firebaseProjectID != rhs.firebaseProjectID {return false}
    if lhs.apiKey != rhs.apiKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModelInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ModelInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
    5: .same(proto: "hash"),
    6: .standard(proto: "model_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.modelType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 5)
    }
    if self.modelType != .typeUnknown {
      try visitor.visitSingularEnumField(value: self.modelType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModelInfo, rhs: ModelInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.modelType != rhs.modelType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModelInfo.ModelType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "CUSTOM"),
  ]
}

extension ModelOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ModelOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_info"),
    4: .standard(proto: "is_model_update_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._modelInfo) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isModelUpdateEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._modelInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.isModelUpdateEnabled != false {
      try visitor.visitSingularBoolField(value: self.isModelUpdateEnabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModelOptions, rhs: ModelOptions) -> Bool {
    if lhs._modelInfo != rhs._modelInfo {return false}
    if lhs.isModelUpdateEnabled != rhs.isModelUpdateEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModelDownloadLogEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ModelDownloadLogEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "options"),
    2: .standard(proto: "rough_download_duration_ms"),
    3: .standard(proto: "error_code"),
    4: .standard(proto: "exact_download_duration_ms"),
    5: .standard(proto: "download_status"),
    6: .standard(proto: "download_failure_status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roughDownloadDurationMs) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.exactDownloadDurationMs) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.downloadStatus) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.downloadFailureStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.roughDownloadDurationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.roughDownloadDurationMs, fieldNumber: 2)
    }
    if self.errorCode != .noError {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 3)
    }
    if self.exactDownloadDurationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.exactDownloadDurationMs, fieldNumber: 4)
    }
    if self.downloadStatus != .unknownStatus {
      try visitor.visitSingularEnumField(value: self.downloadStatus, fieldNumber: 5)
    }
    if self.downloadFailureStatus != 0 {
      try visitor.visitSingularInt64Field(value: self.downloadFailureStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ModelDownloadLogEvent, rhs: ModelDownloadLogEvent) -> Bool {
    if lhs._options != rhs._options {return false}
    if lhs.roughDownloadDurationMs != rhs.roughDownloadDurationMs {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.exactDownloadDurationMs != rhs.exactDownloadDurationMs {return false}
    if lhs.downloadStatus != rhs.downloadStatus {return false}
    if lhs.downloadFailureStatus != rhs.downloadFailureStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ModelDownloadLogEvent.DownloadStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATUS"),
    7: .same(proto: "SUCCEEDED"),
    8: .same(proto: "FAILED"),
  ]
}

extension FirebaseMlLogEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FirebaseMlLogEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_info"),
    2: .standard(proto: "event_name"),
    3: .standard(proto: "model_download_log_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._systemInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.eventName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._modelDownloadLogEvent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._systemInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.eventName != .unknownEvent {
      try visitor.visitSingularEnumField(value: self.eventName, fieldNumber: 2)
    }
    if let v = self._modelDownloadLogEvent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FirebaseMlLogEvent, rhs: FirebaseMlLogEvent) -> Bool {
    if lhs._systemInfo != rhs._systemInfo {return false}
    if lhs.eventName != rhs.eventName {return false}
    if lhs._modelDownloadLogEvent != rhs._modelDownloadLogEvent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

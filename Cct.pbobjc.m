// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cct.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Cct.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - CctRoot

@implementation CctRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - CctRoot_FileDescriptor

static GPBFileDescriptor *CctRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"gdt_cct"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - LogEvent

@implementation LogEvent

@dynamic hasEventTimeMs, eventTimeMs;
@dynamic hasEventUptimeMs, eventUptimeMs;
@dynamic hasSourceExtension, sourceExtension;
@dynamic hasTimezoneOffsetSeconds, timezoneOffsetSeconds;
@dynamic hasNetworkConnectionInfo, networkConnectionInfo;

typedef struct LogEvent__storage_ {
  uint32_t _has_storage_[1];
  NSData *sourceExtension;
  NetworkConnectionInfo *networkConnectionInfo;
  int64_t eventTimeMs;
  int64_t timezoneOffsetSeconds;
  int64_t eventUptimeMs;
} LogEvent__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "eventTimeMs",
        .dataTypeSpecific.className = NULL,
        .number = LogEvent_FieldNumber_EventTimeMs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogEvent__storage_, eventTimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "sourceExtension",
        .dataTypeSpecific.className = NULL,
        .number = LogEvent_FieldNumber_SourceExtension,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LogEvent__storage_, sourceExtension),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timezoneOffsetSeconds",
        .dataTypeSpecific.className = NULL,
        .number = LogEvent_FieldNumber_TimezoneOffsetSeconds,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LogEvent__storage_, timezoneOffsetSeconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeSInt64,
      },
      {
        .name = "eventUptimeMs",
        .dataTypeSpecific.className = NULL,
        .number = LogEvent_FieldNumber_EventUptimeMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogEvent__storage_, eventUptimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "networkConnectionInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NetworkConnectionInfo),
        .number = LogEvent_FieldNumber_NetworkConnectionInfo,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LogEvent__storage_, networkConnectionInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogEvent class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogEvent__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NetworkConnectionInfo

@implementation NetworkConnectionInfo

@dynamic hasNetworkType, networkType;
@dynamic hasMobileSubtype, mobileSubtype;

typedef struct NetworkConnectionInfo__storage_ {
  uint32_t _has_storage_[1];
  NetworkConnectionInfo_NetworkType networkType;
  NetworkConnectionInfo_MobileSubtype mobileSubtype;
} NetworkConnectionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = NetworkConnectionInfo_NetworkType_None,
        .core.name = "networkType",
        .core.dataTypeSpecific.enumDescFunc = NetworkConnectionInfo_NetworkType_EnumDescriptor,
        .core.number = NetworkConnectionInfo_FieldNumber_NetworkType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(NetworkConnectionInfo__storage_, networkType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = NetworkConnectionInfo_MobileSubtype_UnknownMobileSubtype,
        .core.name = "mobileSubtype",
        .core.dataTypeSpecific.enumDescFunc = NetworkConnectionInfo_MobileSubtype_EnumDescriptor,
        .core.number = NetworkConnectionInfo_FieldNumber_MobileSubtype,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(NetworkConnectionInfo__storage_, mobileSubtype),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NetworkConnectionInfo class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(NetworkConnectionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum NetworkConnectionInfo_NetworkType

GPBEnumDescriptor *NetworkConnectionInfo_NetworkType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None\000Mobile\000Wifi\000MobileMms\000MobileSupl\000Mo"
        "bileDun\000MobileHipri\000Wimax\000Bluetooth\000Dumm"
        "y\000Ethernet\000MobileFota\000MobileIms\000MobileCb"
        "s\000WifiP2P\000MobileIa\000MobileEmergency\000Proxy"
        "\000Vpn\000";
    static const int32_t values[] = {
        NetworkConnectionInfo_NetworkType_None,
        NetworkConnectionInfo_NetworkType_Mobile,
        NetworkConnectionInfo_NetworkType_Wifi,
        NetworkConnectionInfo_NetworkType_MobileMms,
        NetworkConnectionInfo_NetworkType_MobileSupl,
        NetworkConnectionInfo_NetworkType_MobileDun,
        NetworkConnectionInfo_NetworkType_MobileHipri,
        NetworkConnectionInfo_NetworkType_Wimax,
        NetworkConnectionInfo_NetworkType_Bluetooth,
        NetworkConnectionInfo_NetworkType_Dummy,
        NetworkConnectionInfo_NetworkType_Ethernet,
        NetworkConnectionInfo_NetworkType_MobileFota,
        NetworkConnectionInfo_NetworkType_MobileIms,
        NetworkConnectionInfo_NetworkType_MobileCbs,
        NetworkConnectionInfo_NetworkType_WifiP2P,
        NetworkConnectionInfo_NetworkType_MobileIa,
        NetworkConnectionInfo_NetworkType_MobileEmergency,
        NetworkConnectionInfo_NetworkType_Proxy,
        NetworkConnectionInfo_NetworkType_Vpn,
    };
    static const char *extraTextFormatInfo = "\001\016d\203\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NetworkConnectionInfo_NetworkType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NetworkConnectionInfo_NetworkType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NetworkConnectionInfo_NetworkType_IsValidValue(int32_t value__) {
  switch (value__) {
    case NetworkConnectionInfo_NetworkType_None:
    case NetworkConnectionInfo_NetworkType_Mobile:
    case NetworkConnectionInfo_NetworkType_Wifi:
    case NetworkConnectionInfo_NetworkType_MobileMms:
    case NetworkConnectionInfo_NetworkType_MobileSupl:
    case NetworkConnectionInfo_NetworkType_MobileDun:
    case NetworkConnectionInfo_NetworkType_MobileHipri:
    case NetworkConnectionInfo_NetworkType_Wimax:
    case NetworkConnectionInfo_NetworkType_Bluetooth:
    case NetworkConnectionInfo_NetworkType_Dummy:
    case NetworkConnectionInfo_NetworkType_Ethernet:
    case NetworkConnectionInfo_NetworkType_MobileFota:
    case NetworkConnectionInfo_NetworkType_MobileIms:
    case NetworkConnectionInfo_NetworkType_MobileCbs:
    case NetworkConnectionInfo_NetworkType_WifiP2P:
    case NetworkConnectionInfo_NetworkType_MobileIa:
    case NetworkConnectionInfo_NetworkType_MobileEmergency:
    case NetworkConnectionInfo_NetworkType_Proxy:
    case NetworkConnectionInfo_NetworkType_Vpn:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum NetworkConnectionInfo_MobileSubtype

GPBEnumDescriptor *NetworkConnectionInfo_MobileSubtype_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownMobileSubtype\000Gprs\000Edge\000Umts\000Cdma"
        "\000Evdo0\000EvdoA\000Rtt\000Hsdpa\000Hsupa\000Hspa\000Iden\000E"
        "vdoB\000Lte\000Ehrpd\000Hspap\000Gsm\000TdScdma\000Iwlan\000L"
        "teCa\000Combined\000";
    static const int32_t values[] = {
        NetworkConnectionInfo_MobileSubtype_UnknownMobileSubtype,
        NetworkConnectionInfo_MobileSubtype_Gprs,
        NetworkConnectionInfo_MobileSubtype_Edge,
        NetworkConnectionInfo_MobileSubtype_Umts,
        NetworkConnectionInfo_MobileSubtype_Cdma,
        NetworkConnectionInfo_MobileSubtype_Evdo0,
        NetworkConnectionInfo_MobileSubtype_EvdoA,
        NetworkConnectionInfo_MobileSubtype_Rtt,
        NetworkConnectionInfo_MobileSubtype_Hsdpa,
        NetworkConnectionInfo_MobileSubtype_Hsupa,
        NetworkConnectionInfo_MobileSubtype_Hspa,
        NetworkConnectionInfo_MobileSubtype_Iden,
        NetworkConnectionInfo_MobileSubtype_EvdoB,
        NetworkConnectionInfo_MobileSubtype_Lte,
        NetworkConnectionInfo_MobileSubtype_Ehrpd,
        NetworkConnectionInfo_MobileSubtype_Hspap,
        NetworkConnectionInfo_MobileSubtype_Gsm,
        NetworkConnectionInfo_MobileSubtype_TdScdma,
        NetworkConnectionInfo_MobileSubtype_Iwlan,
        NetworkConnectionInfo_MobileSubtype_LteCa,
        NetworkConnectionInfo_MobileSubtype_Combined,
    };
    static const char *extraTextFormatInfo = "\001\005d\201\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NetworkConnectionInfo_MobileSubtype)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NetworkConnectionInfo_MobileSubtype_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NetworkConnectionInfo_MobileSubtype_IsValidValue(int32_t value__) {
  switch (value__) {
    case NetworkConnectionInfo_MobileSubtype_UnknownMobileSubtype:
    case NetworkConnectionInfo_MobileSubtype_Gprs:
    case NetworkConnectionInfo_MobileSubtype_Edge:
    case NetworkConnectionInfo_MobileSubtype_Umts:
    case NetworkConnectionInfo_MobileSubtype_Cdma:
    case NetworkConnectionInfo_MobileSubtype_Evdo0:
    case NetworkConnectionInfo_MobileSubtype_EvdoA:
    case NetworkConnectionInfo_MobileSubtype_Rtt:
    case NetworkConnectionInfo_MobileSubtype_Hsdpa:
    case NetworkConnectionInfo_MobileSubtype_Hsupa:
    case NetworkConnectionInfo_MobileSubtype_Hspa:
    case NetworkConnectionInfo_MobileSubtype_Iden:
    case NetworkConnectionInfo_MobileSubtype_EvdoB:
    case NetworkConnectionInfo_MobileSubtype_Lte:
    case NetworkConnectionInfo_MobileSubtype_Ehrpd:
    case NetworkConnectionInfo_MobileSubtype_Hspap:
    case NetworkConnectionInfo_MobileSubtype_Gsm:
    case NetworkConnectionInfo_MobileSubtype_TdScdma:
    case NetworkConnectionInfo_MobileSubtype_Iwlan:
    case NetworkConnectionInfo_MobileSubtype_LteCa:
    case NetworkConnectionInfo_MobileSubtype_Combined:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - IosClientInfo

@implementation IosClientInfo

@dynamic hasOsMajorVersion, osMajorVersion;
@dynamic hasOsFullVersion, osFullVersion;
@dynamic hasApplicationBuild, applicationBuild;
@dynamic hasCountry, country;
@dynamic hasModel, model;
@dynamic hasLanguageCode, languageCode;
@dynamic hasApplicationBundleId, applicationBundleId;

typedef struct IosClientInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *osMajorVersion;
  NSString *osFullVersion;
  NSString *applicationBuild;
  NSString *country;
  NSString *model;
  NSString *languageCode;
  NSString *applicationBundleId;
} IosClientInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "osMajorVersion",
        .dataTypeSpecific.className = NULL,
        .number = IosClientInfo_FieldNumber_OsMajorVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(IosClientInfo__storage_, osMajorVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "osFullVersion",
        .dataTypeSpecific.className = NULL,
        .number = IosClientInfo_FieldNumber_OsFullVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(IosClientInfo__storage_, osFullVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "applicationBuild",
        .dataTypeSpecific.className = NULL,
        .number = IosClientInfo_FieldNumber_ApplicationBuild,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(IosClientInfo__storage_, applicationBuild),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "country",
        .dataTypeSpecific.className = NULL,
        .number = IosClientInfo_FieldNumber_Country,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(IosClientInfo__storage_, country),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = IosClientInfo_FieldNumber_Model,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(IosClientInfo__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "languageCode",
        .dataTypeSpecific.className = NULL,
        .number = IosClientInfo_FieldNumber_LanguageCode,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(IosClientInfo__storage_, languageCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "applicationBundleId",
        .dataTypeSpecific.className = NULL,
        .number = IosClientInfo_FieldNumber_ApplicationBundleId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(IosClientInfo__storage_, applicationBundleId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[IosClientInfo class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(IosClientInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ClientInfo

@implementation ClientInfo

@dynamic hasClientType, clientType;
@dynamic hasIosClientInfo, iosClientInfo;

typedef struct ClientInfo__storage_ {
  uint32_t _has_storage_[1];
  ClientInfo_ClientType clientType;
  IosClientInfo *iosClientInfo;
} ClientInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueEnum = ClientInfo_ClientType_IosFirebase,
        .core.name = "clientType",
        .core.dataTypeSpecific.enumDescFunc = ClientInfo_ClientType_EnumDescriptor,
        .core.number = ClientInfo_FieldNumber_ClientType,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(ClientInfo__storage_, clientType),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "iosClientInfo",
        .core.dataTypeSpecific.className = GPBStringifySymbol(IosClientInfo),
        .core.number = ClientInfo_FieldNumber_IosClientInfo,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(ClientInfo__storage_, iosClientInfo),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ClientInfo class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(ClientInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum ClientInfo_ClientType

GPBEnumDescriptor *ClientInfo_ClientType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "IosFirebase\000";
    static const int32_t values[] = {
        ClientInfo_ClientType_IosFirebase,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ClientInfo_ClientType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ClientInfo_ClientType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ClientInfo_ClientType_IsValidValue(int32_t value__) {
  switch (value__) {
    case ClientInfo_ClientType_IosFirebase:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BatchedLogRequest

@implementation BatchedLogRequest

@dynamic logRequestArray, logRequestArray_Count;

typedef struct BatchedLogRequest__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *logRequestArray;
} BatchedLogRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "logRequestArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LogRequest),
        .number = BatchedLogRequest_FieldNumber_LogRequestArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BatchedLogRequest__storage_, logRequestArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BatchedLogRequest class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BatchedLogRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogRequest

@implementation LogRequest

@dynamic hasRequestTimeMs, requestTimeMs;
@dynamic hasRequestUptimeMs, requestUptimeMs;
@dynamic hasClientInfo, clientInfo;
@dynamic hasLogSource, logSource;
@dynamic logEventArray, logEventArray_Count;
@dynamic hasQosTier, qosTier;

typedef struct LogRequest__storage_ {
  uint32_t _has_storage_[1];
  int32_t logSource;
  QosTierConfiguration_QosTier qosTier;
  ClientInfo *clientInfo;
  NSMutableArray *logEventArray;
  int64_t requestTimeMs;
  int64_t requestUptimeMs;
} LogRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "clientInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(ClientInfo),
        .number = LogRequest_FieldNumber_ClientInfo,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(LogRequest__storage_, clientInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "logSource",
        .dataTypeSpecific.className = NULL,
        .number = LogRequest_FieldNumber_LogSource,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(LogRequest__storage_, logSource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "logEventArray",
        .dataTypeSpecific.className = GPBStringifySymbol(LogEvent),
        .number = LogRequest_FieldNumber_LogEventArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LogRequest__storage_, logEventArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "requestTimeMs",
        .dataTypeSpecific.className = NULL,
        .number = LogRequest_FieldNumber_RequestTimeMs,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogRequest__storage_, requestTimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "requestUptimeMs",
        .dataTypeSpecific.className = NULL,
        .number = LogRequest_FieldNumber_RequestUptimeMs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogRequest__storage_, requestUptimeMs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "qosTier",
        .dataTypeSpecific.enumDescFunc = QosTierConfiguration_QosTier_EnumDescriptor,
        .number = LogRequest_FieldNumber_QosTier,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(LogRequest__storage_, qosTier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogRequest class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - QosTierConfiguration

@implementation QosTierConfiguration

@dynamic hasQosTier, qosTier;
@dynamic hasLogSource, logSource;

typedef struct QosTierConfiguration__storage_ {
  uint32_t _has_storage_[1];
  QosTierConfiguration_QosTier qosTier;
  int32_t logSource;
} QosTierConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "qosTier",
        .dataTypeSpecific.enumDescFunc = QosTierConfiguration_QosTier_EnumDescriptor,
        .number = QosTierConfiguration_FieldNumber_QosTier,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QosTierConfiguration__storage_, qosTier),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "logSource",
        .dataTypeSpecific.className = NULL,
        .number = QosTierConfiguration_FieldNumber_LogSource,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(QosTierConfiguration__storage_, logSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QosTierConfiguration class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QosTierConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum QosTierConfiguration_QosTier

GPBEnumDescriptor *QosTierConfiguration_QosTier_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Default\000UnmeteredOnly\000UnmeteredOrDaily\000F"
        "astIfRadioAwake\000Never\000";
    static const int32_t values[] = {
        QosTierConfiguration_QosTier_Default,
        QosTierConfiguration_QosTier_UnmeteredOnly,
        QosTierConfiguration_QosTier_UnmeteredOrDaily,
        QosTierConfiguration_QosTier_FastIfRadioAwake,
        QosTierConfiguration_QosTier_Never,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(QosTierConfiguration_QosTier)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:QosTierConfiguration_QosTier_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL QosTierConfiguration_QosTier_IsValidValue(int32_t value__) {
  switch (value__) {
    case QosTierConfiguration_QosTier_Default:
    case QosTierConfiguration_QosTier_UnmeteredOnly:
    case QosTierConfiguration_QosTier_UnmeteredOrDaily:
    case QosTierConfiguration_QosTier_FastIfRadioAwake:
    case QosTierConfiguration_QosTier_Never:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - QosTiersOverride

@implementation QosTiersOverride

@dynamic qosTierConfigurationArray, qosTierConfigurationArray_Count;
@dynamic hasQosTierFingerprint, qosTierFingerprint;

typedef struct QosTiersOverride__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *qosTierConfigurationArray;
  int64_t qosTierFingerprint;
} QosTiersOverride__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "qosTierConfigurationArray",
        .dataTypeSpecific.className = GPBStringifySymbol(QosTierConfiguration),
        .number = QosTiersOverride_FieldNumber_QosTierConfigurationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(QosTiersOverride__storage_, qosTierConfigurationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qosTierFingerprint",
        .dataTypeSpecific.className = NULL,
        .number = QosTiersOverride_FieldNumber_QosTierFingerprint,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(QosTiersOverride__storage_, qosTierFingerprint),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[QosTiersOverride class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(QosTiersOverride__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LogResponse

@implementation LogResponse

@dynamic hasNextRequestWaitMillis, nextRequestWaitMillis;
@dynamic hasQosTier, qosTier;

typedef struct LogResponse__storage_ {
  uint32_t _has_storage_[1];
  QosTiersOverride *qosTier;
  int64_t nextRequestWaitMillis;
} LogResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nextRequestWaitMillis",
        .dataTypeSpecific.className = NULL,
        .number = LogResponse_FieldNumber_NextRequestWaitMillis,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LogResponse__storage_, nextRequestWaitMillis),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "qosTier",
        .dataTypeSpecific.className = GPBStringifySymbol(QosTiersOverride),
        .number = LogResponse_FieldNumber_QosTier,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LogResponse__storage_, qosTier),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LogResponse class]
                                     rootClass:[CctRoot class]
                                          file:CctRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LogResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
